# converters/bt_765_PartFrameworkAgreement.py

import logging
from typing import Optional, Dict
from lxml import etree

logger = logging.getLogger(__name__)

def parse_part_framework_agreement(xml_content: str) -> Optional[Dict]:
    """
    Parse the XML content to extract the Framework Agreement details for the Part.

    Args:
        xml_content (str): The XML content to parse.

    Returns:
        Optional[Dict]: A dictionary containing the parsed data if found, None otherwise.
    """
    if isinstance(xml_content, str):
        xml_content = xml_content.encode('utf-8')
    root = etree.fromstring(xml_content)
    namespaces = {
    'cac': 'urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2',
    'ext': 'urn:oasis:names:specification:ubl:schema:xsd:CommonExtensionComponents-2',
    'cbc': 'urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2',
    'efac': 'http://data.europa.eu/p27/eforms-ubl-extension-aggregate-components/1',
    'efext': 'http://data.europa.eu/p27/eforms-ubl-extensions/1',
    'efbc': 'http://data.europa.eu/p27/eforms-ubl-extension-basic-components/1'
}

    method_mapping = {
        'fa-mix': 'withAndWithoutReopeningCompetition',
        'fa-w-rc': 'withReopeningCompetition',
        'fa-wo-rc': 'withoutReopeningCompetition'
    }

    framework_agreement = root.xpath("//cac:ProcurementProjectLot[cbc:ID/@schemeName='Part']/cac:TenderingProcess/cac:ContractingSystem[cbc:ContractingSystemTypeCode/@listName='framework-agreement']/cbc:ContractingSystemTypeCode/text()", namespaces=namespaces)

    if framework_agreement and framework_agreement[0] != 'none':
        mapped_method = method_mapping.get(framework_agreement[0])
        if mapped_method:
            return {
                "tender": {
                    "techniques": {
                        "hasFrameworkAgreement": True,
                        "frameworkAgreement": {
                            "method": mapped_method
                        }
                    }
                }
            }

    return None

def merge_part_framework_agreement(release_json: Dict, part_framework_agreement_data: Optional[Dict]) -> None:
    """
    Merge the parsed Part Framework Agreement data into the main OCDS release JSON.

    Args:
        release_json (Dict): The main OCDS release JSON to be updated.
        part_framework_agreement_data (Optional[Dict]): The parsed Part Framework Agreement data to be merged.

    Returns:
        None: The function updates the release_json in-place.
    """
    if not part_framework_agreement_data:
        logger.warning("No Part Framework Agreement data to merge")
        return

    tender = release_json.setdefault("tender", {})
    techniques = tender.setdefault("techniques", {})

    techniques.update(part_framework_agreement_data["tender"]["techniques"])

    logger.info("Merged Part Framework Agreement data")
    # tests/test_bt_767_Lot.py

import pytest
from lxml import etree
from ted_and_doffin_to_ocds.converters.BT_767_Lot import parse_electronic_auction, merge_electronic_auction
import json
import os
import sys

# Add the parent directory to sys.path to import main
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from main import main

def test_parse_electronic_auction():
    xml_content = """
    <root xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2"
          xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2">
        <cac:ProcurementProjectLot>
            <cbc:ID schemeName="Lot">LOT-0001</cbc:ID>
            <cac:TenderingProcess>
                <cac:AuctionTerms>
                    <cbc:AuctionConstraintIndicator>true</cbc:AuctionConstraintIndicator>
                </cac:AuctionTerms>
            </cac:TenderingProcess>
        </cac:ProcurementProjectLot>
    </root>
    """
    
    result = parse_electronic_auction(xml_content)
    
    assert result is not None
    assert "tender" in result
    assert "lots" in result["tender"]
    assert len(result["tender"]["lots"]) == 1
    assert result["tender"]["lots"][0]["id"] == "LOT-0001"
    assert result["tender"]["lots"][0]["techniques"]["hasElectronicAuction"] == True

def test_merge_electronic_auction():
    release_json = {
        "tender": {
            "lots": [
                {
                    "id": "LOT-0001",
                    "title": "Existing Lot"
                }
            ]
        }
    }
    
    electronic_auction_data = {
        "tender": {
            "lots": [
                {
                    "id": "LOT-0001",
                    "techniques": {
                        "hasElectronicAuction": True
                    }
                }
            ]
        }
    }
    
    merge_electronic_auction(release_json, electronic_auction_data)
    
    assert "techniques" in release_json["tender"]["lots"][0]
    assert release_json["tender"]["lots"][0]["techniques"]["hasElectronicAuction"] == True

def test_bt_767_lot_electronic_auction_integration(tmp_path):
    xml_content = """
    <root xmlns:cac="urn:oasis:names:specification:ubl:schema:xsd:CommonAggregateComponents-2"
          xmlns:cbc="urn:oasis:names:specification:ubl:schema:xsd:CommonBasicComponents-2">
        <cac:ProcurementProjectLot>
            <cbc:ID schemeName="Lot">LOT-0001</cbc:ID>
            <cac:TenderingProcess>
                <cac:AuctionTerms>
                    <cbc:AuctionConstraintIndicator>true</cbc:AuctionConstraintIndicator>
                </cac:AuctionTerms>
            </cac:TenderingProcess>
        </cac:ProcurementProjectLot>
        <cac:ProcurementProjectLot>
            <cbc:ID schemeName="Lot">LOT-0002</cbc:ID>
            <cac:TenderingProcess>
                <cac:AuctionTerms>
                    <cbc:AuctionConstraintIndicator>false</cbc:AuctionConstraintIndicator>
                </cac:AuctionTerms>
            </cac:TenderingProcess>
        </cac:ProcurementProjectLot>
        <cac:ProcurementProjectLot>
            <cbc:ID schemeName="Lot">LOT-0003</cbc:ID>
            <cac:TenderingProcess>
                <cac:OtherTerms>
                    <cbc:SomeOtherIndicator>true</cbc:SomeOtherIndicator>
                </cac:OtherTerms>
            </cac:TenderingProcess>
        </cac:ProcurementProjectLot>
    </root>
    """
    xml_file = tmp_path / "test_input_electronic_auction.xml"
    xml_file.write_text(xml_content)

    main(str(xml_file), "ocds-test-prefix")

    with open('output.json', 'r') as f:
        result = json.load(f)

    assert "tender" in result
    assert "lots" in result["tender"]
    
    lots_with_electronic_auction = [lot for lot in result["tender"]["lots"] if "techniques" in lot and "hasElectronicAuction" in lot["techniques"]]
    assert len(lots_with_electronic_auction) == 2

    lot_1 = next((lot for lot in lots_with_electronic_auction if lot["id"] == "LOT-0001"), None)
    assert lot_1 is not None
    assert lot_1["techniques"]["hasElectronicAuction"] is True

    lot_2 = next((lot for lot in lots_with_electronic_auction if lot["id"] == "LOT-0002"), None)
    assert lot_2 is not None
    assert lot_2["techniques"]["hasElectronicAuction"] is False

    lot_3 = next((lot for lot in result["tender"]["lots"] if lot["id"] == "LOT-0003"), None)
    assert lot_3 is not None
    assert "techniques" not in lot_3 or "hasElectronicAuction" not in lot_3.get("techniques", {})

if __name__ == "__main__":
    pytest.main()

# main.py
from ted_and_doffin_to_ocds.converters.BT_503_Organization_Company import parse_organization_contact_telephone, merge_organization_contact_telephone
from ted_and_doffin_to_ocds.converters.BT_503_Organization_TouchPoint import parse_touchpoint_contact_telephone, merge_touchpoint_contact_telephone
from ted_and_doffin_to_ocds.converters.BT_503_UBO import parse_ubo_telephone, merge_ubo_telephone
from ted_and_doffin_to_ocds.converters.BT_505_Organization_Company import parse_organization_website, merge_organization_website
from ted_and_doffin_to_ocds.converters.BT_505_Organization_TouchPoint import parse_touchpoint_website, merge_touchpoint_website
from ted_and_doffin_to_ocds.converters.BT_506_Organization_Company import parse_organization_contact_email, merge_organization_contact_email
from ted_and_doffin_to_ocds.converters.BT_506_Organization_TouchPoint import parse_touchpoint_contact_email, merge_touchpoint_contact_email
from ted_and_doffin_to_ocds.converters.BT_506_UBO import parse_ubo_email, merge_ubo_email
from ted_and_doffin_to_ocds.converters.BT_510a_Organization_Company import parse_organization_street, merge_organization_street
from ted_and_doffin_to_ocds.converters.BT_510a_Organization_TouchPoint import parse_touchpoint_street, merge_touchpoint_street
from ted_and_doffin_to_ocds.converters.BT_510a_UBO import parse_ubo_street, merge_ubo_street
from ted_and_doffin_to_ocds.converters.BT_510b_Organization_Company import parse_organization_streetline1, merge_organization_streetline1
from ted_and_doffin_to_ocds.converters.BT_510b_Organization_TouchPoint import parse_touchpoint_streetline1, merge_touchpoint_streetline1
from ted_and_doffin_to_ocds.converters.BT_510b_UBO import parse_ubo_streetline1, merge_ubo_streetline1
from ted_and_doffin_to_ocds.converters.BT_510c_Organization_Company import parse_organization_streetline2, merge_organization_streetline2



def configure_logging():
    # Create a logger
    logger = logging.getLogger()
    logger.setLevel(logging.DEBUG)

    # Create formatter
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s', datefmt='%Y-%m-%d %H:%M:%S')

    # Create file handler and set level to info
    file_handler = logging.FileHandler('app.log', mode='w')
    file_handler.setLevel(logging.INFO)
    file_handler.setFormatter(formatter)

    # Add handler to logger
    logger.addHandler(file_handler)

def remove_empty_elements(data):
    """
    Recursively remove empty lists, empty dicts, or None elements from a dictionary or list.
    Preserves False boolean values and zero numeric values.
    """
    if isinstance(data, dict):
        return {
            key: remove_empty_elements(value)
            for key, value in data.items()
            if value is not None and (value or isinstance(value, (bool, int, float)))
        }
    elif isinstance(data, list):
        return [
            remove_empty_elements(item)
            for item in data
            if item is not None and (item or isinstance(item, (bool, int, float)))
        ]
    else:
        return data

# Additional step to remove keys with empty dictionaries
def remove_empty_dicts(data):
    if isinstance(data, dict):
        return {
            key: remove_empty_dicts(value)
            for key, value in data.items()
            if value or isinstance(value, (bool, int, float))
        }
    elif isinstance(data, list):
        return [remove_empty_dicts(item) for item in data if item or isinstance(item, (bool, int, float))]
    else:
        return data

def main(xml_path, ocid_prefix):
    # Read the XML content from the file
    with open(xml_path, 'rb') as xml_file:
        xml_content = xml_file.read()

    configure_logging()
    logger = logging.getLogger(__name__)
    logger.info(f"Starting XML to JSON conversion for file: {xml_path}")

    # Initialize NoticeProcessor
    notice_processor = NoticeProcessor(ocid_prefix)

    # Create the release JSON
    release_json_str = notice_processor.create_release(xml_content)
    release_json = json.loads(release_json_str)  # Parse the JSON string into a dictionary
	
	
	
	# Parse and merge BT-752-Lot-ThresholdNumber Selection Criteria Second Stage Invite Threshold Number
    try:
        threshold_number_data = parse_selection_criteria_threshold_number(xml_content)
        if threshold_number_data:
            merge_selection_criteria_threshold_number(release_json, threshold_number_data)
            logger.info("BT-752-Lot-ThresholdNumber: Successfully merged Selection Criteria Threshold Number data")
        else:
            logger.info("BT-752-Lot-ThresholdNumber: No Selection Criteria Threshold Number data found")
    except Exception as e:
        logger.error(f"BT-752-Lot-ThresholdNumber: Error processing Selection Criteria Threshold Number data: {str(e)}")

    # Parse and merge BT-752-Lot-WeightNumber Selection Criteria Second Stage Invite Weight Number
    try:
        weight_number_data = parse_selection_criteria_weight_number(xml_content)
        if weight_number_data:
            merge_selection_criteria_weight_number(release_json, weight_number_data)
            logger.info("BT-752-Lot-WeightNumber: Successfully merged Selection Criteria Weight Number data")
        else:
            logger.info("BT-752-Lot-WeightNumber: No Selection Criteria Weight Number data found")
    except Exception as e:
        logger.error(f"BT-752-Lot-WeightNumber: Error processing Selection Criteria Weight Number data: {str(e)}")

    # Parse and merge BT-7531-Lot Selection Criteria Second Stage Invite Number Weight
    try:
        number_weight_data = parse_selection_criteria_number_weight(xml_content)
        if number_weight_data:
            merge_selection_criteria_number_weight(release_json, number_weight_data)
            logger.info("BT-7531-Lot: Successfully merged Selection Criteria Number Weight data")
        else:
            logger.info("BT-7531-Lot: No Selection Criteria Number Weight data found")
    except Exception as e:
        logger.error(f"BT-7531-Lot: Error processing Selection Criteria Number Weight data: {str(e)}")

    # Parse and merge BT-510(c)-Organization-Company (Streetline 2)
    try:
        organization_streetline2_data = parse_organization_streetline2(xml_content)
        if organization_streetline2_data:
            merge_organization_streetline2(release_json, organization_streetline2_data)
            logger.info("BT-510(c)-Organization-Company: Successfully merged Organization Streetline 2 data")
        else:
            logger.info("BT-510(c)-Organization-Company: No Organization Streetline 2 data found")
    except Exception as e:
        logger.error(f"BT-510(c)-Organization-Company: Error processing Organization Streetline 2 data: {str(e)}")
		
		
		
	# Before applying remove_empty_elements and remove_empty_dicts
    #logger.info(f"Release JSON before removing empty elements: {json.dumps(release_json, indent=2)}")
    
    release_json = remove_empty_elements(release_json)
    #logger.info(f"Release JSON after removing empty elements: {json.dumps(release_json, indent=2)}")

    release_json = remove_empty_dicts(release_json)
    #logger.info(f"Release JSON after removing empty dicts: {json.dumps(release_json, indent=2)}")

    # Before writing to output.json
    logger.info(f"Final release JSON: {json.dumps(release_json, indent=2)}")

    # Write the JSON output to a file
    with io.open('output.json', 'w', encoding='utf-8') as f:
        json.dump(release_json, f, ensure_ascii=False)

    logger.info("XML to JSON conversion completed")

    # Print the JSON string to console
    json_string = json.dumps(release_json, ensure_ascii=False)
    

    return release_json

if __name__ == "__main__":
    # Path to the XML file
    xml_path = 'xmlfile/can_24_minimal.xml'
    #xml_path = 'bt_198-106.xml'
    # Prefix for OCID
    ocid_prefix = 'ocid_prefix_value'
    
    main(xml_path, ocid_prefix)

# common operations
Create a release¶
If the notice is a prior information or periodic indicative notice used only for information (PIN only), you should repeat the following steps for each part (/*/cac:ProcurementProjectLot[cbc:ID/@schemeName='Part']) because each part is treated as a separate planning process. Otherwise, you need only perform the steps once per notice.

Create an empty JSON object

Set its id to the notice identifier (/*/cbc:ID).

Set its initiationType to 'tender'.

Set its ocid as described below.

If any of the following are true, assign a new ocid by prepending your OCID prefix to a unique identifier of your choice (e.g. a version 4 UUID or a suitable system-internal identifier):

The notice is the first publication concerning the procedure.

The notice is a contract award notice (CAN) for an award within a framework agreement or dynamic purchasing system.

The previous publication concerning the procedure is a PIN only notice. Notices following a PIN only notice are assigned a new ocid because they may be defined based on multiple parts.

Otherwise, set ocid to the same value as the previous publication's ocid.

Reference a previous publication¶
If the Previous publication concerning this procedure is neither a prior information notice nor a periodic indicative notice (PIN), or if the PIN has a single /*/cac:ProcurementProjectLot (Object) element, then discard /*/cbc:ID. In this case, the previous publication concerning this procedure is the OCDS release with the same ocid as this release and with the nearest earlier date to this release.

Otherwise, if the Previous publication concerning this procedure is a prior information notice or periodic indicative notice that has multiple /*/cac:ProcurementProjectLot (Object) elements, add a RelatedProcess object to the relatedProcesses array, set its .id to '1', add 'planning' to its .relationship array, set its .scheme to 'eu-oj' (or to a scheme of your choice if outside the EU), and map /*/cbc:ID to .identifier.

Convert a date to ISO format¶
OCDS dates must be formatted according to ISO 8601 and include a time component.

If a time component is missing from a date, use 'T23:59:59Z' for end dates and 'T00:00:00Z' for other dates.

If a timezone component is present in the date (e.g. '+02:00'), preserve it. Otherwise, use the UTC timezone indicate 'Z'.

The final value would be '2020-10-21T23:59:59Z' or '2020-10-21T00:00:00Z'.

Add a complaints statistic¶
Add a Statistic object to the statistics array, set its .relatedLot to the value of ancestor::efac:LotResult/efac:TenderLot/cbc:ID, set its scope to 'complaints', and set its .id (string) sequentially across all notices for this procedure. For example, if a first notice for a given procedure has nine statistics, it uses id's '1' through '9'. A second notice for the same procedure then uses id's '10' and up, etc.

Add a bids statistic¶
Add a Statistic object to the bids.statistics array, set its .relatedLot to the value of ancestor::efac:LotResult/efac:TenderLot/cbc:ID, and set its .id (string) sequentially across all notices for this procedure. For example, if a first notice for a given procedure has nine bid statistics, it uses id's '1' through '9'. A second notice for the same procedure then uses id's '10' and up, etc.

Get the document for a document reference¶
Get the Document object in tender.documents whose .id is equal to the document reference's /cbc:ID. If none exists yet, add a Document object to tender.documents and set its .id to the document reference's /cbc:ID.

Get the participation fee for a document¶
If the value of ancestor::cac:ProcurementProjectLot[cbc:ID/@schemeName] is 'Part', get the ParticipationFee object in tender.participationFees whose .id is equal to cac:CallForTendersDocumentReference/cbc:ID. If none exists yet, add a ParticipationFee object to tender.participationFees and set its .id to the value of ancestor::cac:CallForTendersDocumentReference/cbc:ID.

If the value of ancestor::cac:ProcurementProjectLot[cbc:ID/@schemeName] is 'Lot', get the lot for the ProcurementProjectLot and get the ParticipationFee object in the lot's .participationFees whose .id is equal to cac:CallForTendersDocumentReference/cbc:ID. If none exists yet, add a ParticipationFee object to the lot's .participationFees and set its .id to the value of ancestor::cac:CallForTendersDocumentReference/cbc:ID.

Get a translation¶
Download 'business-term_XX.xml' from eForms SDK translations for the language required, where XX is the 2 letter language code. Find the row with the key 'business-term|description|BT-##' for the business term required (for example 'business-term|description|BT-160') and take the value from the entry.

Parties¶
Add a party¶
Add an Organization object to the parties array, and set its .id (string). A party's .id needs to be consistent across all notices. It is recommended to implement a register of organization identifiers to assign consistent identifiers. For more information, see the OCDS documentation.

Get the organization for a company¶
Get the Organization in parties whose id is equal to the value of ancestor::efac:Organization/efac:Company/cac:PartyIdentification/cbc:ID. If none exists yet:

Add an Organization to parties

Set its .id to the value of the ancestor::efac:Organization/efac:Company/cac:PartyIdentification/cbc:ID.

Get the organization for a touchpoint¶
Get the Organization in parties whose id is equal to the value of ancestor::efac:TouchPoint/cac:PartyIdentification/cbc:ID. If none exists yet:

Add an Organization to parties

Set its .id to the value of ancestor::efac:TouchPoint/cac:PartyIdentification/cbc:ID

Set its .identifier.id to the value of ancestor::efac:Organization/efac:Company/cac:PartyLegalEntity/cbc:CompanyID

Set its .identifier.scheme.

Get the organization for the buyer¶
Get the Organization in parties whose .id is equal to the value of ancestor::cac:ContractingParty/cac:Party/cac:PartyIdentification/cbc:ID. If none exists yet:

Add an Organization to parties

Set its .id to the value of ancestor::cac:ContractingParty/cac:Party/cac:PartyIdentification/cbc:ID

Add 'buyer' to it's .roles

Get the organization for a tenderer¶
Get the Organization in parties whose .id is equal to the value of ancestor::efac:TenderingParty/efac:Tenderer/cbc:ID. If none exists yet:

Add an Organization to parties

Set its .id to the value of ancestor::efac:TenderingParty/efac:Tenderer/cbc:ID

Add 'tenderer' to it's .roles

Get the person for an ultimate beneficial owner¶
Get the Organization in parties whose id is equal to the value of ancestor::efac:Organization/efac:Company/cac:PartyIdentification/cbc:ID. If none exists yet:

Add an Organization to parties

Set its .id to the value of ancestor::efac:Organization/efac:Company/cac:PartyIdentification/cbc:ID.

Get the Person in the organization's .beneficialOwners array whose id is equal to the value of ancestor::efac:UltimateBeneficialOwner/cbc:ID. If none exists yet:

Add a Person to .beneficialOwners

Set its .id to the value of ancestor::efac:UltimateBeneficialOwner/cbc:ID.

Note

ancestor::efac:UltimateBeneficialOwner/cbc:ID is assumed to be a unique within the scope of the contracting process.

Get the organization for an organization technical identifier reference¶
Get the Organization object in parties whose .id is equal to the organization technical identifier reference's /cbc:ID. If none exists yet, add an Organization object to parties and set its .id to the organization technical identifier reference's /cbc:ID.

Lots and items¶
Get the lot for a ProcurementProjectLot¶
Get the Lot in tender.lots whose .id is equal to the value of ancestor::cac:ProcurementProjectLot/cbc:ID. If none exists yet, add a Lot to tender.lots and set its id to the value of ancestor::cac:ProcurementProjectLot/cbc:ID.

Get the lot group for a ProcurementProjectLot¶
Get the LotGroup in tender.lotGroups whose .id is equal to the value of the XPath ancestor::cac:ProcurementProjectLot/cbc:ID. If none exists yet, add a LotGroup to tender.lotGroups and set its id to the value of the XPath ancestor::cac:ProcurementProjectLot/cbc:ID.

Get the item for a ProcurementProjectLot¶
Get the Item in tender.items whose .relatedLot is equal to the value of ancestor::cac:ProcurementProjectLot/cbc:ID. If none exists yet, add an Item to tender.items, set its .id incrementally and set its .relatedLot to the value of ancestor::cac:ProcurementProjectLot/cbc:ID.

Get the lot for a LotResult¶
Get the Lot in tender.lots whose id is equal to the value of ancestor::efac:LotResult/efac:TenderLot/cbc:ID. If none exists yet, add a Lot to tender.lots and set its id to the value of ancestor::efac:LotResult/efac:TenderLot/cbc:ID.

Get the lots for a SettledContract¶
For each ancestor::efac:NoticeResult/efac:LotResult with a /efac:SettledContract/cbc:ID equal to the value of ancestor::efac:SettledContract/cbc:ID, get the Lot in tender/lots whose .id is equal to the value of the LotResult's /efac:TenderLot/cbc:ID.

Get the lot for a LotTender¶
Get the Lot object in tender.lots whose .id matches ancestor::efac:LotTender/efac:TenderLot:cbc:ID. If none exists yet, add a Lot to tender.lots and set its id to the value of ancestor::efac:LotTender/efac:TenderLot:cbc:ID.

Bids, awards and contracts¶
Get the bid for a LotTender¶
Get the Bid in bids.details whose id is equal to the value of ancestor::efac:LotTender/cbc:ID. If none exists yet:

Add a Bid object to the bids.details array

Set its .id to the value of ancestor::efac:LotTender/cbc:ID

Add the value of ancestor::efac:LotTender/efac:TenderLot/cbc:ID to its .relatedLots

Get the award for a LotResult¶
Get the Award in awards whose id is equal to the value of ancestor::efac:LotResult/cbc:ID. If none exists yet:

Add an Award to awards

Set its .id to the value of ancestor::efac:LotResult/cbc:ID

Add the value of ancestor::efac:LotResult/efac:TenderLot/cbc:ID to its .relatedLots

Get the contract for a SettledContract¶
Get the Contract in contracts whose .id is equal to ancestor::efac:SettledContract/cbc:ID. If none exists yet:

Add a Contract to contracts

Set its .id to the value of ancestor::efac:SettledContract/cbc:ID

Get all LotResults (ancestor::efac:NoticeResult/efac:LotResult) with an /efac:SettledContract/cbc:ID equal to ancestor::efac:SettledContract/cbc:ID

If there is exactly one, add its /cbc:ID to the contract's .awardID

If there is more than one, add each LotResult's /cbc:ID to the contract's .awardIDs

write support for 
